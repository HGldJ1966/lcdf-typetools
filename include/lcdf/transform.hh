// -*- related-file-name: "../../liblcdf/transform.cc" -*-
#ifndef LCDF_TRANSFORM_HH
#define LCDF_TRANSFORM_HH
#include <lcdf/bezier.hh>
#include <cassert>

class Transform { public:

    Transform();
    Transform(const double[6]);
    Transform(double, double, double, double, double, double);
    // Transform(const Transform &)	generated by compiler
    // ~Transform()			generated by compiler

    double value(int i) const		{ assert(i>=0&&i<6); return _m[i]; }
    bool null() const			{ return _null; }
    void check_null(double tolerance);
  
    void add_scale(double, double);
    void add_scale(const Point &p)		{ add_scale(p.x, p.y); }
    void add_scale(double d)			{ add_scale(d, d); }
    void add_rotate(double);
    void add_translate(double, double);
    void add_translate(const Point &p)		{ add_translate(p.x, p.y); }

    inline Transform scaled(double, double) const;
    Transform scaled(const Point &p) const	{ return scaled(p.x, p.y); }
    Transform scaled(double d) const		{ return scaled(d, d); }
    Transform rotated(double) const;
    Transform translated(double, double) const;
    Transform translated(const Point &p) const;
    Transform transformed(const Transform &) const;

    // Transform operator+(Transform, const Point &);
    // Transform &operator+=(Transform &, const Point &);
    // Transform operator*(Transform, double);
    // Transform &operator*=(Transform &, double);
    // Transform operator*(Transform, const Transform &);
    // Transform &operator*=(Transform &, const Transform &);
    friend Point operator*(const Point &, const Transform &);
    friend Point &operator*=(Point &, const Transform &);
    friend Bezier operator*(const Bezier &, const Transform &);
    friend Bezier &operator*=(Bezier &, const Transform &);

  private:
    
    double _m[6];
    bool _null;

    void real_apply_to(Point &) const;
    Point real_apply(const Point &) const;

};


inline Transform
Transform::scaled(double x, double y) const
{
    Transform t(*this);
    t.add_scale(x, y);
    return t;
}

inline Transform
Transform::rotated(double r) const
{
    Transform t(*this);
    t.add_rotate(r);
    return t;
}

inline Transform
Transform::translated(double x, double y) const
{
    Transform t(*this);
    t.add_translate(x, y);
    return t;
}

inline Transform
Transform::translated(const Point &p) const
{
    return translated(p.x, p.y);
}


inline Transform &
operator+=(Transform &t, const Point &p)
{
    t.add_translate(p);
    return t;
}

inline Transform
operator+(Transform t, const Point &p)
{
    return t += p;
}

inline Transform &
operator*=(Transform &t, double scale)
{
    t.add_scale(scale);
    return t;
}

inline Transform
operator*(Transform t, double scale)
{
    return t *= scale;
}

inline Transform
operator*(const Transform &t, const Transform &tt)
{
    return t.transformed(tt);
}

inline Transform &
operator*=(Transform &t, const Transform &tt)
{
    t = t.transformed(tt);
    return t;
}


inline Point &
operator*=(Point &p, const Transform &t)
{
    if (!t.null())
	t.real_apply_to(p);
    return p;
}

inline Point
operator*(const Point &p, const Transform &t)
{
    return (t.null() ? p : t.real_apply(p));
}

#endif
