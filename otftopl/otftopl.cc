#ifdef HAVE_CONFIG_H
# include <config.h>
#endif
#include <efont/psres.hh>
#include <efont/t1rw.hh>
#include <efont/t1font.hh>
#include <efont/t1item.hh>
#include <efont/t1bounds.hh>
#include <efont/otfcmap.hh>
#include <efont/otfgsub.hh>
#include "gsubencoding.hh"
#include <lcdf/clp.h>
#include <lcdf/error.hh>
#include <efont/cff.hh>
#include <efont/otf.hh>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cstdarg>
#include <cctype>
#include <cerrno>
#include <algorithm>
#ifdef HAVE_CTIME
# include <ctime>
#endif

using namespace Efont;

#define VERSION_OPT	301
#define HELP_OPT	302
#define QUIET_OPT	303
#define OUTPUT_OPT	304
#define FEATURE_OPT	305

Clp_Option options[] = {
    { "feature", 'f', FEATURE_OPT, Clp_ArgString, 0 },
    { "help", 'h', HELP_OPT, 0, 0 },
    { "output", 'o', OUTPUT_OPT, Clp_ArgString, 0 },
    { "quiet", 'q', QUIET_OPT, 0, Clp_Negate },
    { "version", 0, VERSION_OPT, 0, 0 },
};


static const char *program_name;
static PermString::Initializer initializer;
static PermString dot_notdef(".notdef");
static Vector<Efont::OpenType::Tag> interesting_features;


void
usage_error(ErrorHandler *errh, char *error_message, ...)
{
    va_list val;
    va_start(val, error_message);
    if (!error_message)
	errh->message("Usage: %s [OPTION]... FONT", program_name);
    else
	errh->verror(ErrorHandler::Error, String(), error_message, val);
    errh->message("Type %s --help for more information.", program_name);
    exit(1);
}

void
usage()
{
    printf("\
`Mmpfb' creates a single-master PostScript Type 1 font by interpolating a\n\
multiple master font at a point you specify. The resulting font does not\n\
contain multiple master extensions. It is written to the standard output.\n\
\n\
Usage: %s [OPTION]... FONT\n\
\n\
FONT is either the name of a PFA or PFB multiple master font file, or a\n\
PostScript font name. In the second case, mmpfb will find the actual outline\n\
file using the PSRESOURCEPATH environment variable.\n\
\n\
General options:\n\
      --amcp-info              Print AMCP info, if necessary, and exit.\n\
  -a, --pfa                    Output PFA font.\n\
  -b, --pfb                    Output PFB font. This is the default.\n\
  -o, --output=FILE            Write output to FILE.\n\
  -p, --precision=N            Set precision to N (larger means more precise).\n\
  -h, --help                   Print this message and exit.\n\
  -q, --quiet                  Do not generate any error messages.\n\
      --version                Print version number and exit.\n\
\n\
Interpolation settings:\n\
  -w, --weight=N               Set weight to N.\n\
  -W, --width=N                Set width to N.\n\
  -O, --optical-size=N         Set optical size to N.\n\
      --style=N                Set style axis to N.\n\
  --1=N, --2=N, --3=N, --4=N   Set first (second, third, fourth) axis to N.\n\
\n\
Report bugs to <eddietwo@lcs.mit.edu>.\n", program_name);
}


// MAIN

typedef EfontCFF Ec;

struct AFMKeyword {
    Ec::DictOperator op;
    Ec::DictType type;
    const char *name;
};
static AFMKeyword afm_keywords[] = {
    { Ec::oFullName, Ec::tSID, "FullName" },
    { Ec::oFamilyName, Ec::tSID, "FamilyName" },
    { Ec::oWeight, Ec::tSID, "Weight" },
    { Ec::oFontBBox, Ec::tArray4, "FontBBox" },
    { Ec::oVersion, Ec::tSID, "Version" },
    { Ec::oNotice, Ec::tSID, "Notice" },
    { Ec::oUnderlinePosition, Ec::tNumber, "UnderlinePosition" },
    { Ec::oUnderlineThickness, Ec::tNumber, "UnderlineThickness" },
    { Ec::oItalicAngle, Ec::tNumber, "ItalicAngle" },
    { Ec::oIsFixedPitch, Ec::tNumber, "IsFixedPitch" },
    { Ec::oVersion, Ec::tNone, 0 }
};

static void
output_afm(OpenType::Font *, EfontCFF::Font *cff, FILE *f)
{
    fprintf(f, "StartFontMetrics 4.1\n\
Comment Generated by otftoafm (LCDF t1sicle)\n\
FontName %s\n",
	    cff->font_name().cc());

    for (const AFMKeyword *kw = afm_keywords; kw->name; kw++)
	switch (kw->type) {
	  case Ec::tSID:
	    if (String s = cff->dict_string(kw->op))
		fprintf(f, "%s %s\n", kw->name, s.cc());
	    break;
	  case Ec::tArray4: {
	      Vector<double> v;
	      if (cff->dict_value(kw->op, v) && v.size() == 4)
		  fprintf(f, "%s %g %g %g %g\n", kw->name, v[0], v[1], v[2], v[3]);
	      break;
	  }
	  case Ec::tNumber: {
	      double n;
	      if (cff->dict_value(kw->op, UNKDOUBLE, &n) && KNOWN(n))
		  fprintf(f, "%s %g\n", kw->name, n);
	      break;
	  }
	  default:
	    break;
	}

    // per-glyph metrics
    int nglyphs = cff->nglyphs();
    fprintf(f, "StartCharMetrics %d\n", nglyphs);
    
    HashMap<PermString, int> glyph_map(-1);

    CharstringBounds boundser(cff);
    int bounds[4], width;
    Charstring *cs;
    
    Type1Encoding *encoding = cff->type1_encoding();
    for (int i = 0; i < 256; i++) {
	PermString n = (*encoding)[i];
	if (glyph_map[n] <= 0 && (cs = cff->glyph(n))) {
	    boundser.run(*cs, bounds, width);
	    fprintf(f, "C %d ; WX %d ; N %s ; B %d %d %d %d ;\n",
		    i, width, n.cc(), bounds[0], bounds[1], bounds[2], bounds[3]);
	    glyph_map.insert(n, 1);
	}
    }

    Vector<PermString> glyph_names;
    cff->glyph_names(glyph_names);
    for (int i = 0; i < glyph_names.size(); i++)
	if (glyph_map[glyph_names[i]] <= 0 && (cs = cff->glyph(i))) {
	    boundser.run(*cs, bounds, width);
	    fprintf(f, "C -1 ; WX %d ; N %s ; B %d %d %d %d ;\n",
		    width, glyph_names[i].cc(), bounds[0], bounds[1], bounds[2], bounds[3]);
	}
    
    fprintf(f, "EndCharMetrics\n");
    
    fprintf(f, "EndFontMetrics\n");
}

static uint32_t eka_encoding[256] = {
    // 00
    0x0393, 0x0394, 0x0398, 0x039B, 0x039E, 0x03A0, 0x03A3, 0x03A5,
    0x03A6, 0x03A8, 0x03A9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    // 10
    0x0131, 0x0000, 0x0300, 0x0301, 0x030C, 0x0306, 0x0304, 0x030A,
    0x0327, 0x00DF, 0x00E6, 0x0153, 0x00F8, 0x00C6, 0x0152, 0x00D8,
    // 20
    0x0020, 0x0021, 0x201D, 0x0023, 0x0024, 0x0025, 0x0026, 0x2019,
    0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
    // 30
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003A, 0x003B, 0x00A1, 0x003D, 0x00BF, 0x003F,
    // 40
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
    // 50
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005A, 0x005B, 0x201C, 0x005D, 0x0302, 0x0307,
    // 60
    0x2018, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
    // 70
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007A, 0x2013, 0x2014, 0x030B, 0x0303, 0x0308,
    // 80
    0x00C1, 0x00C2, 0x00C4, 0x00C0, 0x00C5, 0x00C3, 0x0000, 0x00C7,
    0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x0000, 0x0000, 0x0000, 0x00D0,
    // 90
    0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x0000, 0x0000, 0x0141, 0x00D1,
    0x00D3, 0x00D4, 0x00D6, 0x00D2, 0x00D5, 0x0000, 0x0160, 0x00DE,
    // A0
    0x00DA, 0x00DB, 0x00DC, 0x00D9, 0x0000, 0x00DD, 0x0178, 0x017D,
    0x00E1, 0x00E2, 0x00E4, 0x00E0, 0x2039, 0x203A, 0x00C5, 0x00E3,
    // B0
    0x00E7, 0x00E9, 0x00EA, 0x00EF, 0x00E8, 0x0000, 0x0000, 0x00D0,
    0x00ED, 0x00EE, 0x00EB, 0x00EC, 0x0000, 0x0000, 0x0142, 0x00F1,
    // C0
    0x00F3, 0x00F4, 0x00F6, 0x00F2, 0x00F5, 0x0000, 0x0161, 0x00FE,
    0x00FA, 0x00FB, 0x00FC, 0x00F9, 0x0000, 0x00FD, 0x00FF, 0x017E,
    // D0
    0x00A7, 0x00B6, 0x2020, 0x2021, 0x00A2, 0x2022, 0x00A3, 0x0000,
    0x00AB, 0x00BB, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    // E0
    0x007B, 0x007D, 0x005C, 0x2212, 0x003C, 0x003E, 0x007C, 0x005E,
    0x007E, 0x00B5, 0x005F, 0x00A9, 0x00A5, 0x0000, 0x0000, 0x0000,
    // F0
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

static void
do_file(const char *infn, const char *outfn,
	PsresDatabase *, ErrorHandler *errh)
{
    FILE *f;
    if (!infn || strcmp(infn, "-") == 0) {
	f = stdin;
	infn = "<stdin>";
    } else if (!(f = fopen(infn, "rb")))
	errh->fatal("%s: %s", infn, strerror(errno));
  
    int c = getc(f);
    ungetc(c, f);

    if (c == EOF)
	errh->fatal("%s: empty file", infn);
    if (c != 'O')
	errh->fatal("%s: not an OpenType/CFF font", infn);

    StringAccum sa(150000);
    while (!feof(f)) {
	int forward = fread(sa.reserve(32768), 1, 32768, f);
	sa.forward(forward);
    }
    if (f != stdin)
	fclose(f);

    PinnedErrorHandler cerrh(errh, infn);
    OpenType::Font otf(sa.take_string(), &cerrh);
    if (!otf.ok())
	return;

    EfontCFF cff(otf.table("CFF"), &cerrh);
    if (!cff.ok())
	return;

    EfontCFF::Font font(&cff, PermString(), &cerrh);
    if (!font.ok())
	return;

    // XXX
    {
	OpenType::Gsub gsub(otf.table("GSUB"), &cerrh);

	// get the list of available features for our script
	Vector<int> fids;
	int required_fid;
	gsub.script_list().features("latn", 0U, required_fid, fids, &cerrh);

	// print out available feature tags
	const OpenType::FeatureList &flist = gsub.feature_list();
	if (required_fid >= 0)
	    fprintf(stderr, "<%s>! ", flist.feature_tag(required_fid).text().cc());
	for (int i = 0; i < fids.size(); i++)
	    fprintf(stderr, "%s ", flist.feature_tag(fids[i]).text().cc());
	fprintf(stderr, "\n");

	// fetch glyph names
	Vector<PermString> glyph_names;
	font.glyph_names(glyph_names);

	// initialize encoding
	GsubEncoding encoding;
	OpenType::Cmap cmap(otf.table("cmap"), &cerrh);
	assert(cmap.ok());
	for (int i = 0; i < 256; i++)
	    if (eka_encoding[i])
		if (OpenType::Glyph g = cmap.map_uni(eka_encoding[i]))
		    encoding.encode(i, g);
	
	// get lookups
	Vector<int> lookups;
	gsub.feature_list().lookups(required_fid, fids, interesting_features, lookups, errh);
	Vector<OpenType::Substitution> subs;
	for (int i = 0; i < lookups.size(); i++) {
	    fprintf(stderr, "Lookup %d:\n", lookups[i]);
	    OpenType::GsubLookup l = gsub.lookup(lookups[i]);
	    l.unparse_automatics(subs);
	    for (int i = 0; i < subs.size(); i++) {
		encoding.apply(subs[i]);
		fprintf(stderr, "  %s\n", subs[i].unparse(&glyph_names).c_str());
	    }
	    encoding.apply_substitutions();
	}

	encoding.simplify_ligatures(false);
	encoding.shrink_encoding(256);
	encoding.unparse(&glyph_names);
    }

    if (!outfn || strcmp(outfn, "-") == 0) {
	f = stdout;
	outfn = "<stdout>";
    } else if (!(f = fopen(outfn, "w")))
	errh->fatal("%s: %s", outfn, strerror(errno));

    output_afm(&otf, &font, f);

    if (f != stdout)
	fclose(f);
}

int
main(int argc, char **argv)
{
    PsresDatabase *psres = new PsresDatabase;
    psres->add_psres_path(getenv("PSRESOURCEPATH"), 0, false);
  
    Clp_Parser *clp =
	Clp_NewParser(argc, argv, sizeof(options) / sizeof(options[0]), options);
    program_name = Clp_ProgramName(clp);
  
    ErrorHandler *default_errh = new FileErrorHandler(stderr);
    ErrorHandler *errh = default_errh;
    const char *input_file = 0;
    const char *output_file = 0;
  
    while (1) {
	int opt = Clp_Next(clp);
	switch (opt) {

	  case FEATURE_OPT: {
	      OpenType::Tag t(clp->arg);
	      if (t.ok())
		  interesting_features.push_back(t);
	      else
		  usage_error(errh, "bad feature tag");
	      break;
	  }
      
	  case QUIET_OPT:
	    if (clp->negated)
		errh = default_errh;
	    else
		errh = ErrorHandler::silent_handler();
	    break;
      
	  case VERSION_OPT:
	    printf("otftoafm (LCDF t1sicle) %s\n", VERSION);
	    printf("Copyright (C) 2002 Eddie Kohler\n\
This is free software; see the source for copying conditions.\n\
There is NO warranty, not even for merchantability or fitness for a\n\
particular purpose.\n");
	    exit(0);
	    break;
      
	  case HELP_OPT:
	    usage();
	    exit(0);
	    break;

	  case OUTPUT_OPT:
	  output_file:
	    if (output_file)
		usage_error(errh, "output file specified twice");
	    output_file = clp->arg;
	    break;

	  case Clp_NotOption:
	    if (input_file && output_file)
		usage_error(errh, "too many arguments");
	    else if (input_file)
		goto output_file;
	    else
		input_file = clp->arg;
	    break;
      
	  case Clp_Done:
	    goto done;
      
	  case Clp_BadOption:
	    usage_error(errh, 0);
	    break;
      
	  default:
	    break;
      
	}
    }
  
  done:
    if (interesting_features.size())
	std::sort(interesting_features.begin(), interesting_features.end());
    
    do_file(input_file, output_file, psres, errh);
    
    return (errh->nerrors() == 0 ? 0 : 1);
}
