#ifdef HAVE_CONFIG_H
# include <config.h>
#endif
#include <efont/psres.hh>
#include <efont/t1rw.hh>
#include <efont/t1font.hh>
#include <efont/t1item.hh>
#include <efont/t1bounds.hh>
#include <efont/otfcmap.hh>
#include <efont/otfgsub.hh>
#include "gsubencoding.hh"
#include "dvipsencoding.hh"
#include "util.hh"
#include <lcdf/clp.h>
#include <lcdf/error.hh>
#include <efont/cff.hh>
#include <efont/otf.hh>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cstdarg>
#include <cctype>
#include <cerrno>
#include <algorithm>
#ifdef HAVE_CTIME
# include <ctime>
#endif

using namespace Efont;

#define VERSION_OPT	301
#define HELP_OPT	302
#define QUIET_OPT	303
#define OUTPUT_OPT	304
#define FEATURE_OPT	305
#define GLYPHLIST_OPT	306
#define ENCODING_OPT	307

Clp_Option options[] = {
    { "encoding", 'e', ENCODING_OPT, Clp_ArgString, 0 },
    { "feature", 'f', FEATURE_OPT, Clp_ArgString, 0 },
    { "glyphlist", 0, GLYPHLIST_OPT, Clp_ArgString, 0 },
    { "help", 'h', HELP_OPT, 0, 0 },
    { "output", 'o', OUTPUT_OPT, Clp_ArgString, 0 },
    { "quiet", 'q', QUIET_OPT, 0, Clp_Negate },
    { "version", 0, VERSION_OPT, 0, 0 },
};


static const char *program_name;
static PermString::Initializer initializer;
static PermString dot_notdef(".notdef");
static Vector<Efont::OpenType::Tag> interesting_features;


void
usage_error(ErrorHandler *errh, char *error_message, ...)
{
    va_list val;
    va_start(val, error_message);
    if (!error_message)
	errh->message("Usage: %s [OPTION]... FONT", program_name);
    else
	errh->verror(ErrorHandler::Error, String(), error_message, val);
    errh->message("Type %s --help for more information.", program_name);
    exit(1);
}

void
usage()
{
    printf("\
%s\n\
\n\
General options:\n\
  -f, --feature=FEAT           Apply feature FEAT.\n\
  -e, --encoding=FILE          Use DVIPS encoding FILE.\n\
      --glyphlist=FILE         Use FILE to map Adobe glyph names to Unicode.\n\
  -h, --help                   Print this message and exit.\n\
  -q, --quiet                  Do not generate any error messages.\n\
      --version                Print version number and exit.\n\
\n\
Report bugs to <kohler@icir.org>.\n", program_name);
}


// MAIN

typedef EfontCFF Ec;

struct AFMKeyword {
    Ec::DictOperator op;
    Ec::DictType type;
    const char *name;
};
static AFMKeyword afm_keywords[] = {
    { Ec::oFullName, Ec::tSID, "FullName" },
    { Ec::oFamilyName, Ec::tSID, "FamilyName" },
    { Ec::oWeight, Ec::tSID, "Weight" },
    { Ec::oFontBBox, Ec::tArray4, "FontBBox" },
    { Ec::oVersion, Ec::tSID, "Version" },
    { Ec::oNotice, Ec::tSID, "Notice" },
    { Ec::oUnderlinePosition, Ec::tNumber, "UnderlinePosition" },
    { Ec::oUnderlineThickness, Ec::tNumber, "UnderlineThickness" },
    { Ec::oItalicAngle, Ec::tNumber, "ItalicAngle" },
    { Ec::oIsFixedPitch, Ec::tNumber, "IsFixedPitch" },
    { Ec::oVersion, Ec::tNone, 0 }
};

static void
output_afm(EfontCFF::Font *cff, FILE *f)
{
    fprintf(f, "StartFontMetrics 4.1\n\
Comment Generated by otftoafm (LCDF t1sicle)\n\
FontName %s\n",
	    cff->font_name().cc());

    for (const AFMKeyword *kw = afm_keywords; kw->name; kw++)
	switch (kw->type) {
	  case Ec::tSID:
	    if (String s = cff->dict_string(kw->op))
		fprintf(f, "%s %s\n", kw->name, s.cc());
	    break;
	  case Ec::tArray4: {
	      Vector<double> v;
	      if (cff->dict_value(kw->op, v) && v.size() == 4)
		  fprintf(f, "%s %g %g %g %g\n", kw->name, v[0], v[1], v[2], v[3]);
	      break;
	  }
	  case Ec::tNumber: {
	      double n;
	      if (cff->dict_value(kw->op, UNKDOUBLE, &n) && KNOWN(n))
		  fprintf(f, "%s %g\n", kw->name, n);
	      break;
	  }
	  default:
	    break;
	}

    // per-glyph metrics
    int nglyphs = cff->nglyphs();
    fprintf(f, "StartCharMetrics %d\n", nglyphs);
    
    HashMap<PermString, int> glyph_map(-1);

    CharstringBounds boundser(cff);
    int bounds[4], width;
    Charstring *cs;
    
    Type1Encoding *encoding = cff->type1_encoding();
    for (int i = 0; i < 256; i++) {
	PermString n = (*encoding)[i];
	if (glyph_map[n] <= 0 && (cs = cff->glyph(n))) {
	    boundser.run(*cs, bounds, width);
	    fprintf(f, "C %d ; WX %d ; N %s ; B %d %d %d %d ;\n",
		    i, width, n.cc(), bounds[0], bounds[1], bounds[2], bounds[3]);
	    glyph_map.insert(n, 1);
	}
    }

    Vector<PermString> glyph_names;
    cff->glyph_names(glyph_names);
    for (int i = 0; i < glyph_names.size(); i++)
	if (glyph_map[glyph_names[i]] <= 0 && (cs = cff->glyph(i))) {
	    boundser.run(*cs, bounds, width);
	    fprintf(f, "C -1 ; WX %d ; N %s ; B %d %d %d %d ;\n",
		    width, glyph_names[i].cc(), bounds[0], bounds[1], bounds[2], bounds[3]);
	}
    
    fprintf(f, "EndCharMetrics\n");
    
    fprintf(f, "EndFontMetrics\n");
}

static const char * const digit_names[] = {
    "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"
};

static void
output_vpl(EfontCFF::Font *cff, const GsubEncoding &gse, FILE *f)
{
    //XXX is DESIGNSIZE in points?
    fprintf(f, "(VTITLE foo)\n"
	    "(COMMENT foo)\n"
	    "(FAMILY foo)\n"
	    "(CODINGSCHEME foo)\n"
	    "(DESIGNSIZE R 10.0)\n"
	    "(DESIGNUNITS R 1000)\n"
	    "(COMMENT DESIGNSIZE (1 em) IS IN POINTS)\n"
	    "(COMMENT OTHER DIMENSIONS ARE MULTIPLES OF DESIGNSIZE/1000)\n"
	    "(FONTDIMEN\n"
	    "   (SPACE D XXX)\n"
	    "   (STRETCH D 200)\n"
	    "   (SHRINK D 100)\n"
	    "   (XHEIGHT D 440)\n"
	    "   (QUAD D 1000)\n"
	    "   (EXTRASPACE D 111)\n"
	    "   )\n"
	    "(MAPFONT D 0\n"
	    "   (FONTNAME XXX)\n"
	    "   )\n");

    // figure out the proper names and numbers for glyphs
    Vector<PermString> glyph_names;
    cff->glyph_names(glyph_names);
    Vector<String> glyph_ids;
    Vector<String> glyph_comments(256, String());
    for (int i = 0; i < 256; i++)
	if (OpenType::Glyph g = gse.glyph(i)) {
	    PermString name = glyph_names[g];
	    PermString expected_name;
	    if (i >= '0' && i <= '9')
		expected_name = digit_names[i - '0'];
	    else if ((i >= 'A' && i <= 'Z') || (i >= 'a' && i <= 'z'))
		expected_name = PermString((char)i);
	    if (expected_name && name.length() >= expected_name.length()
		&& memcmp(name.c_str(), expected_name.c_str(), expected_name.length()) == 0)
		glyph_ids.push_back("C " + String((char)i));
	    else
		glyph_ids.push_back("D " + String(i));
	    if (name != expected_name)
		glyph_comments[i] = " (COMMENT " + String(name) + ")";
	} else
	    glyph_ids.push_back("X");

    // LIGTABLE
    fprintf(f, "(LIGTABLE\n");
    Vector<int> lig_code2, lig_outcode, lig_skip, kern_code2, kern_amt;
    for (int i = 0; i < 256; i++)
	if (gse.glyph(i)) {
	    int any_lig = gse.twoligatures(i, lig_code2, lig_outcode, lig_skip);
	    int any_kern = gse.kerns(i, kern_code2, kern_amt);
	    if (any_lig || any_kern) {
		fprintf(f, "   (LABEL %s)%s\n", glyph_ids[i].c_str(), glyph_comments[i].c_str());
		for (int j = 0; j < lig_code2.size(); j++)
		    fprintf(f, "   (LIG %s %s)%s%s\n",
			    glyph_ids[lig_code2[j]].c_str(),
			    glyph_ids[lig_outcode[j]].c_str(),
			    glyph_comments[lig_code2[j]].c_str(),
			    glyph_comments[lig_outcode[j]].c_str());
		for (int j = 0; j < kern_code2.size(); j++)
		    fprintf(f, "   (KRN %s R %d)%s\n",
			    glyph_ids[kern_code2[j]].c_str(),
			    kern_amt[j],
			    glyph_comments[kern_code2[j]].c_str());
		fprintf(f, "   (STOP)\n");
	    }
	}
    
    // CHARACTERs
    CharstringBounds boundser(cff);
    int bounds[4], width;
    
    for (int i = 0; i < 256; i++)
	if (OpenType::Glyph g = gse.glyph(i)) {
	    fprintf(f, "(CHARACTER %s%s\n", glyph_ids[i].c_str(), glyph_comments[i].c_str());
	    Charstring *cs = cff->glyph(g);
	    boundser.run(*cs, bounds, width);
	    fprintf(f, "   (CHARWD R %d)\n", width);
	    if (bounds[3] > 0)
		fprintf(f, "   (CHARHT R %d)\n", bounds[3]);
	    if (bounds[1] < 0)
		fprintf(f, "   (CHARDP R %d)\n", -bounds[1]);
	    if (bounds[2] > width)
		fprintf(f, "   (CHARIC R %d)\n", bounds[2] - width);
	    fprintf(f, "   )\n");
	}
}

static void
do_file(const char *infn, const char *outfn,
	PsresDatabase *, const DvipsEncoding &dvipsenc_in, ErrorHandler *errh)
{
    FILE *f;
    if (!infn || strcmp(infn, "-") == 0) {
	f = stdin;
	infn = "<stdin>";
    } else if (!(f = fopen(infn, "rb")))
	errh->fatal("%s: %s", infn, strerror(errno));
  
    int c = getc(f);
    ungetc(c, f);

    if (c == EOF)
	errh->fatal("%s: empty file", infn);
    if (c != 'O')
	errh->fatal("%s: not an OpenType/CFF font", infn);

    StringAccum sa(150000);
    while (!feof(f)) {
	int forward = fread(sa.reserve(32768), 1, 32768, f);
	sa.forward(forward);
    }
    if (f != stdin)
	fclose(f);

    PinnedErrorHandler cerrh(errh, infn);
    OpenType::Font otf(sa.take_string(), &cerrh);
    if (!otf.ok())
	return;

    EfontCFF cff(otf.table("CFF"), &cerrh);
    if (!cff.ok())
	return;

    EfontCFF::Font font(&cff, PermString(), &cerrh);
    if (!font.ok())
	return;

    // prepare encoding
    DvipsEncoding dvipsenc;
    if (dvipsenc_in)
	dvipsenc = dvipsenc_in;
    else if (Type1Encoding *t1e = font.type1_encoding()) {
	for (int i = 0; i < 256; i++)
	    dvipsenc.encode(i, (*t1e)[i]);
    }
    
    // XXX
    OpenType::Gsub gsub(otf.table("GSUB"), &cerrh);
    OpenType::Gpos gpos(otf.table("GPOS"), &cerrh);

    // get the list of available features for our script
    Vector<int> fids;
    int required_fid;
    gsub.script_list().features("latn", 0U, required_fid, fids, &cerrh);

    // print out available feature tags
    const OpenType::FeatureList &flist = gpos.feature_list();
    if (required_fid >= 0)
	fprintf(stderr, "<%s>! ", flist.feature_tag(required_fid).text().cc());
    for (int i = 0; i < fids.size(); i++)
	fprintf(stderr, "%s ", flist.feature_tag(fids[i]).text().cc());
    fprintf(stderr, "\n");

    // initialize encoding
    GsubEncoding encoding;
    OpenType::Cmap cmap(otf.table("cmap"), &cerrh);
    assert(cmap.ok());
    dvipsenc.make_gsub_encoding(encoding, cmap, &font);
    
    // fetch glyph names
    Vector<PermString> glyph_names;
    font.glyph_names(glyph_names);

    // get lookups for GSUB
    Vector<int> lookups;
    gsub.feature_list().lookups(required_fid, fids, interesting_features, lookups, errh);
    Vector<OpenType::Substitution> subs;
    for (int i = 0; i < lookups.size(); i++) {
	OpenType::GsubLookup l = gsub.lookup(lookups[i]);
	l.unparse_automatics(subs);
	for (int i = 0; i < subs.size(); i++)
	    encoding.apply(subs[i]);
	encoding.apply_substitutions();
    }

    encoding.simplify_ligatures(false);
    encoding.shrink_encoding(256);
    
    // get lookups for GPOS
    gpos.feature_list().lookups(required_fid, fids, interesting_features, lookups, errh);
    Vector<OpenType::Positioning> poss;
    for (int i = 0; i < lookups.size(); i++) {
	OpenType::GposLookup l = gpos.lookup(lookups[i]);
	l.unparse_automatics(poss);
	for (int i = 0; i < poss.size(); i++)
	    encoding.apply(poss[i]);
    }

    //encoding.unparse(&glyph_names);

    if (!outfn || strcmp(outfn, "-") == 0) {
	f = stdout;
	outfn = "<stdout>";
    } else if (!(f = fopen(outfn, "w")))
	errh->fatal("%s: %s", outfn, strerror(errno));

    output_vpl(&font, encoding, f);

    if (f != stdout)
	fclose(f);
}

int
main(int argc, char **argv)
{
    PsresDatabase *psres = new PsresDatabase;
    psres->add_psres_path(getenv("PSRESOURCEPATH"), 0, false);
  
    Clp_Parser *clp =
	Clp_NewParser(argc, argv, sizeof(options) / sizeof(options[0]), options);
    program_name = Clp_ProgramName(clp);
  
    ErrorHandler *default_errh = new FileErrorHandler(stderr);
    ErrorHandler *errh = default_errh;
    const char *input_file = 0;
    const char *output_file = 0;
    const char *glyphlist_file = SHAREDIR "/glyphlist.txt";
    const char *encoding_file = 0;
  
    while (1) {
	int opt = Clp_Next(clp);
	switch (opt) {

	  case FEATURE_OPT: {
	      OpenType::Tag t(clp->arg);
	      if (t.ok())
		  interesting_features.push_back(t);
	      else
		  usage_error(errh, "bad feature tag");
	      break;
	  }
      
	  case QUIET_OPT:
	    if (clp->negated)
		errh = default_errh;
	    else
		errh = ErrorHandler::silent_handler();
	    break;

	  case GLYPHLIST_OPT:
	    glyphlist_file = clp->arg;
	    break;
	    
	  case ENCODING_OPT:
	    encoding_file = clp->arg;
	    break;
	    
	  case VERSION_OPT:
	    printf("otftoafm (LCDF t1sicle) %s\n", VERSION);
	    printf("Copyright (C) 2002 Eddie Kohler\n\
This is free software; see the source for copying conditions.\n\
There is NO warranty, not even for merchantability or fitness for a\n\
particular purpose.\n");
	    exit(0);
	    break;
      
	  case HELP_OPT:
	    usage();
	    exit(0);
	    break;

	  case OUTPUT_OPT:
	  output_file:
	    if (output_file)
		usage_error(errh, "output file specified twice");
	    output_file = clp->arg;
	    break;

	  case Clp_NotOption:
	    if (input_file && output_file)
		usage_error(errh, "too many arguments");
	    else if (input_file)
		goto output_file;
	    else
		input_file = clp->arg;
	    break;
      
	  case Clp_Done:
	    goto done;
      
	  case Clp_BadOption:
	    usage_error(errh, 0);
	    break;

	  default:
	    break;
      
	}
    }
  
  done:
    // read glyphlist
    if (String s = read_file(glyphlist_file, errh, true))
	DvipsEncoding::parse_glyphlist(s);

    DvipsEncoding dvipsenc;
    if (encoding_file)
	dvipsenc.parse(encoding_file, errh);
    
    if (interesting_features.size())
	std::sort(interesting_features.begin(), interesting_features.end());
    
    do_file(input_file, output_file, psres, dvipsenc, errh);
    
    return (errh->nerrors() == 0 ? 0 : 1);
}

#include <lcdf/vector.cc>
